<button id="run">Run</button>
<table id="table"></table>
<script src="matrix.js"></script>
<script>
    function oneHot( a, length ) {
        const B = empty( [ a.length, length ] );
        for ( let i = a.length; i--; ) B[ i * length + a[ i ] ] = 1;
        return B;
    }

    function randomMinMax(min, max) {
        return Math.random() * (max - min) + min;
    }

    function random( shape ) {
        const A = empty( shape );
        for ( let i = A.length; i--; ) A[ i ] = randomMinMax( -1, 1 );
        return A;
    }

    function sample(probs) {
        const sum = probs.reduce((a, b) => a + b, 0)
        if (sum <= 0) throw Error('probs must sum to a value greater than zero')
        const normalized = probs.map(prob => prob / sum)
        const sample = Math.random()
        let total = 0
        for (let i = 0; i < normalized.length; i++) {
            total += normalized[i]
            if (sample < total) return i
        }
    }

    fetch('https://raw.githubusercontent.com/karpathy/makemore/master/names.txt')
    .then(res => res.text())
    .then(text => {
        const names = text.split('\n');
        const chars = [ ...new Set( names.join('') ) ].sort();
        const totalChars = chars.length + 1;
        const stringToCharMap = chars.reduce( ( map, char, index ) => {
            map[ char ] = index + 1;
            return map;
        }, {} );
        stringToCharMap[ '.' ] = 0;
        indexToCharMap = [ '.', ...chars ];

        // Inputs.
        const xs = [];
        // Targets, or labels.
        const ys = [];

        for ( const name of names ) {
            const exploded = '.' + name + '.';
            i = 1;
            while ( exploded[ i ] ) {
                const bigram = exploded[i - 1] + exploded[i];
                const indexOfChar1 = stringToCharMap[ exploded[ i - 1 ] ];
                const indexOfChar2 = stringToCharMap[ exploded[ i ] ];
                xs.push( indexOfChar1 );
                ys.push( indexOfChar2 );
                i++;
            }
        }

        const neurons = totalChars;
        // One hidden layer.
        const W = new Layer( random( [ totalChars, neurons ] ) );
        const xenc = new Layer( oneHot( xs, totalChars ) );
        const logits = xenc.matMul( W ); // = log counts
        const loss = logits.softmaxCrossEntropy( oneHot( ys, totalChars ) );
        const iterations = 10;

        function makeTable( Weights ) {
            Weights = softmaxByRow( Weights );
            const [ m, n ] = Weights.shape;
            const table = document.getElementById( 'table' );
            table.innerHTML = '';

            for ( let m_ = m; m_--; ) {
                const row = document.createElement( 'tr' );
                for ( let n_ = n; n_--; ) {
                    const cell = document.createElement( 'td' );
                    cell.textContent = Weights[ m_ * n + n_ ].toFixed(2);
                    cell.style.backgroundColor = `rgba( 0, 0, 0, ${ Weights[ m_ * n + n_ ] } )`;
                    row.prepend( cell );
                }

                // Add row head
                const cell = document.createElement( 'td' );
                cell.textContent = indexToCharMap[ m_ ];
                row.prepend( cell );
                table.prepend( row );
            }

            const row = document.createElement( 'tr' );

            for ( let n_ = n; n_--; ) {
                const cell = document.createElement( 'td' );
                cell.textContent = indexToCharMap[ n_ ];
                row.prepend( cell );
            }

            const cell = document.createElement( 'td' );
            row.prepend( cell );
            table.prepend( row );
        }

        makeTable( W.data );

        let lastLoss = Infinity;

        run.onclick = () => {
            for (let i = 0; i < iterations; i++) {
                window.requestIdleCallback( () => {
                    loss.forward();

                    const lossValue = loss.data[0];
                    const action = lossValue < lastLoss ? 'log' : 'error';

                    console[action](`Loss after iteration ${i}: ${lossValue}`);

                    lastLoss = lossValue;

                    loss.backward();

                    for ( let i = W.data.length; i--; ) W.data[ i ] -= 0.1 * W.grad[ i ];
                    makeTable( W.data );
                } );
            }

            window.requestIdleCallback( () => {
                for (let i = 0; i < 5; i++) {
                    const out = []  
                    let ix = 0;

                    while ( true ) {
                        const xenc = oneHot( [ ix ], totalChars );
                        const logits = matMul( xenc, W.data );
                        const probs = softmaxByRow( logits );
                        ix = sample( probs );

                        out.push( indexToCharMap[ ix ] );

                        if ( ix === 0 ) {
                            break;
                        }
                    }

                    console.log( out.join( '' ) );
                }
            } );
        }
    });
</script>