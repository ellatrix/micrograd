<button id="run">Run</button>
<script src="matrix.js"></script>
<script>
    function oneHot( ns, length ) {
        return ns.map( ( n ) => Array.from( { length }, ( _, i ) => n === i ? 1 : 0  ) );
    }

    function randomMinMax(min, max) {
        return Math.random() * (max - min) + min;
    }

    function random( rows, cols ) {
        return Array.from( { length: rows }, () => Array.from( { length: cols }, () => randomMinMax( -1, 1 ) ) );
    }

    function sample(probs) {
        const sum = probs.reduce((a, b) => a + b, 0)
        if (sum <= 0) throw Error('probs must sum to a value greater than zero')
        const normalized = probs.map(prob => prob / sum)
        const sample = Math.random()
        let total = 0
        for (let i = 0; i < normalized.length; i++) {
            total += normalized[i]
            if (sample < total) return i
        }
    }

    fetch('https://raw.githubusercontent.com/karpathy/makemore/master/names.txt')
    .then(res => res.text())
    .then(text => {
        const names = text.split('\n');
        const chars = [ ...new Set( names.join('') ) ].sort();
        const totalChars = chars.length + 1;
        const stringToCharMap = chars.reduce( ( map, char, index ) => {
            map[ char ] = index + 1;
            return map;
        }, {} );
        stringToCharMap[ '.' ] = 0;
        indexToCharMap = [ '.', ...chars ];

        // Inputs.
        const xs = [];
        // Targets, or labels.
        const ys = [];

        for ( const name of names ) {
            const exploded = '.' + name + '.';
            i = 1;
            while ( exploded[ i ] ) {
                const bigram = exploded[i - 1] + exploded[i];
                const indexOfChar1 = stringToCharMap[ exploded[ i - 1 ] ];
                const indexOfChar2 = stringToCharMap[ exploded[ i ] ];
                xs.push( indexOfChar1 );
                ys.push( indexOfChar2 );
                i++;
            }
        }

        const W = new Matrix( random( 27, 27 ) );
        const enc = new Matrix( oneHot( xs, totalChars ) );
        const logits = enc.matMul( W ); // log counts
        const loss = logits.softmaxCrossEntropy( oneHot( ys, totalChars ) );
        const iterations = 10;

        let lastLoss = Infinity;

        run.onclick = () => {
            for (let i = 0; i < iterations; i++) {
                loss.forward();

                const lossValue = loss.data;
                const action = lossValue < lastLoss ? 'log' : 'error';

                console[action](`Loss after iteration ${i}: ${lossValue}`);

                lastLoss = loss.data;

                loss.backward();

                for ( let i = W.data.length; i--; ) W.data[ i ] -= W.grad[ i ];
            }

            for (let i = 0; i < 5; i++) {
                const out = []  
                let ix = 0;

                while ( true ) {
                    const enc = initMatrix( oneHot( [ ix ], totalChars ) );
                    const logits = matMul( enc, W.data );
                    const probs = empty(logits.shape);
                    const [m, n] = logits.shape;
                    // Calculate the softmax for each row.
                    for ( let m_ = m; m_--; ) {
                        let max = -Infinity;
                        let sumExp = 0;
                        for ( let n_ = n; n_--; ) {
                            const value = logits[m_ * n + n_];
                            if (value > max) max = value;
                        }
                        // Softmax.
                        for ( let n_ = n; n_--; ) {
                            // Subtract the max to avoid overflow
                            const expValue = Math.exp(logits[m_ * n + n_] - max);
                            sumExp += expValue;
                            probs[m_ * n + n_] = expValue;
                        }
                        for ( let n_ = n; n_--; ) {
                            probs[m_ * n + n_] /= sumExp;
                        }
                    }
                    ix = sample( probs );

                    out.push( indexToCharMap[ ix ] );

                    if ( ix === 0 ) {
                        break;
                    }
                }

                console.log( out.join( '' ) );
            }
        }
    });
</script>